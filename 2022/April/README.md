# 4月报

## Day.16
这是Day.17补的。

今天画了字符串解析状态机的状态迁移图、指令解析状态迁移图、操作数解析状态迁移图、内存操作数状态迁移图。画完了图，代码就很清晰了，有了这几个状态机，后续的汇编指令可以直接使用字符串来构建。

今天还感悟到一个东西：虚拟机的实现。

我们将cpu和内存抽象出来，用一些结构体变量来表示，cpu由一堆寄存器组成，内存直接就是一个大数组，仅仅这两个东西就可以组成最简单的虚拟机。寄存器变量模拟寄存器，保存单个数据(uint64_t)，并且通过`va2pa()`可以将寄存器变量中保存的虚拟地址转换到内存数组的实际下标。

首先将汇编指令写到内存数组中，然后寄存器去访问内存并读取指令，解析运行后移动指令指针（下一条或者跳转）,这样循环起l来，就是一个最简单的虚拟机了。

## Day.17

今天看完了CSAPP的第三章，对计算机的指令执行体系有了新的认知。

相比于昨天的内容，今天主要是实现了一下汇编指令。`mov call ret push pop` 这几个是前几节课里面讲过的，之前没有写这次补上了，`mov push pop`都是为了某些实验指令特定实现的，参数不通用。`add sub leave jmp jne`这是今天新讲的，涉及到cpu标志位，使用一个`union`+ `struct`实现，可以节省内存，方便清零。其中的`OF`标志格外需要注意，需要推导一下各种溢出情况：同号才会溢出，同号又有两种情况。

这些实现完了，微型虚拟机就完成了（大佬也说这个像虚拟机，我居然猜对了）。

链接开了个头，比较模糊，感觉挺像设计数据存储的，也有magic number之类的，明天好好总结一下。

## Day.18
今天是ELF的第一节课，直接看懵了，符号表好难。

首先，ELF(Excutable Linkable Format)就是常见的`.o`的目标文，使用`gcc -c` 可以获得。这个东西是一个二进制文件，阳明佬准备用txt的文本格式去模拟这个东西，从而实现一个自己的简易链接器（静态的）。
![img](img/ELF结构.png)

上图是ELF文件的结构，从header开始，可以找到SHT，然后根据SHT可以索引到真正的SECTION，gcch以及shell等软件会将这个elf文件加载到内存中，这些SECTION就构成了诸如内存结构中的`代码段`、`数据段`、`.bss段`等区域。这里面最重要的就是一个被称为`符号表(symbol table)`的段，这个和编译原理有些关系，就是将代码中的各种全局变量、函数的`属性`保存在这里。

- bind GLOBAL 
  - 全局的(默认) 
  - LOCAL 局部的(static) 
  - WEAK 弱符号的 (`__attribute__((weak))`)

- type 
  - OBJECT 变量 
  - FUNCTION 函数 
  - NOTYPE(extern且未初始化的变量 extern且未定义的函数)

- index_name 
  - .data(初始化过的变量 **初始化为0不算**) 
  - .bss(未初始化的 **初始化为0放在这个段**) 
  - COMMON(不知道该放在.data还是.bss的悬而未决段)
  - .text(函数)

开始写代码了，先定义了一下上面提到过的数据结构，然后声明了几个函数。希望写完代码能对链接有一个比较清晰的认知。

明天要去青城山玩两天，日报要鸽一下。
